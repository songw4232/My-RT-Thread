# 链表

## 链表知识点目录
链表是一种数据结构，其中每个节点包含一个数据元素和指向下一个节点的指针。链表可以用于解决诸如插入和删除元素等问题，其常用形式包括单向链表、双向链表和循环链表等。以下是链表的主要知识点：

1.单向链表：每个节点都包含一个数据元素和一个指向下一个节点的指针。

2.双向链表：与单向链表类似，但每个节点还包含一个指向上一个节点的指针。

3.循环链表：最后一个节点的指针指向第一个节点，形成了一个环。

4.头指针和头节点：头指针是指向链表第一个节点的指针，而头节点是在单向链表或双向链表中第一个实际存储数据的节点之前的一个节点。

5.链表的插入操作：包括在链表的头部插入节点、在链表的尾部插入节点和在链表的中间插入节点。

6.链表的删除操作：包括删除链表的第一个节点、删除链表的最后一个节点和删除链表的中间节点。

7.链表的遍历：通过从链表的头节点开始沿着链表不断遍历节点，以读取每个节点的数据元素。

8.链表的时间复杂度：链表的插入和删除操作通常具有 O(1) 的时间复杂度，但链表中检索元素的时间复杂度通常是 O(n)，其中 n 是链表的长度。

9.链表与数组的比较：与数组不同，链表的大小可以动态增长或缩小，并且插入和删除操作的开销相对较低。但是，在读取元素时，数组通常比链表更有效率。  

## 链表的基本概念

### 链表和数组的区别
链表和数组是两种常见的数据结构，二者有以下区别：

1.存储方式：数组在内存中使用一块连续的空间来存储元素，而链表则不需要一段连续的空间，每个节点可以储存在任意的内存位置上。

2.访问方式：数组元素可以随机访问，只需要通过下标索引即可；而链表访问时必须从头节点开始依次遍历到目标节点进行访问，所以访问效率较低。

3.大小可变性：数组的大小是固定的，无法动态增删元素，需先预先分配足够空间；而链表大小可以根据需要动态扩展或缩小，具有更高的弹性。

4.插入和删除操作：插入或删除一个元素时，数组需要将该位置后面的元素全部向后（插入）或前移（删除），成本较高；链表仅涉及到前后两个元素的指针变化，成本较小。

5.内存分配：数组需要在创建时一次性地预留足够的内存，在某些情况下会浪费资源；而链表则可以利用堆或栈等动态分配机制，更加灵活、高效。

总之，数组适合于元素数量固定且需要频繁访问的场景；链表适用于频繁进行插入/删除操作，或者元素数量动态变化的场景。 

### 为什么需要头节点
方便插入和删除操作：大多数链表的插入和删除操作都涉及到对链表的头部进行处理，例如在链表头部插入元素、删除链表的第一个元素等，而头节点则可以方便地完成这些操作，同时也保证了链表指向首节点的指针始终有效。   

简化代码实现：链表的各种操作都需要处理链表节点间的连接关系，如果每个节点都需要考虑是否是首节点、尾节点等，代码会变得十分复杂。使用头节点后，其他节点会按照相同的方式链接，使得代码更简洁、易于维护。

综上所述，头节点是链表中必不可少的一个节点，它使链表结构更加完整，并且提供了方便且高效的插入和删除操作。  

![](/figures/lianbiao1_figures/tu1.png)  

## 静态链表

	struct ListNode {
	    int val;            // 数据域
	    struct ListNode* next;   // 指针域，指向下一个节点的指针
	};
这是一个链表节点的定义。  
那么数据域和指针域具体在实际应用中如何定义的，具体指什么？  



### 1.先谈谈对指针的理解

#### 指针不就是地址吗？

一般来说可以这样来理解，就把它当作地址来使用。但今天必须聊的更细致一些！！

地址表示内存单元的位置，而指针则是一个特殊的变量类型，**它包含了数据单元的地址信息以及类型信息**，并可以通过解引用符来访问该地址值所代表的数据。因此，虽然指针和地址密切相关，但二者并不完全相同。

#### 那指针为什么要包含类型信息呢？

指针包含数据类型信息的原因主要有两个：

首先，指针的类型信息是编译器在编译时确定的，它告诉编译器指针所指向的内存区域的数据类型，可以帮助编译器判断使用该指针指向的数据时需要进行哪些操作。例如，在对指针进行计算或者解引用时，编译器能够根据指针的类型来确定相应的步长。

其次，指针的类型信息也有助于程序员和调试器进行代码的正确性检查和调试。如果一个指针的类型不存在或匹配不上，则会在编译阶段或运行阶段产生错误信息，从而帮助程序员尽早地发现程序中的问题并及时处理。

#### 既然有不同的数据类型的指针，为什么所内存字节数都是4？

在大部分计算机中，指针变量通常都占用 4 个字节或 8 个字节。对于 32 位的系统而言，指针变量通常占用 4 个字节，即 32 位；而对于 64 位的系统，则通常使用 8 个字节的指针变量，即 64 位。

这是因为指针实际上只是一个地址值，它并不存储指向对象的实际值，所以指针在内存中所占据的空间只需要足够存储一个地址值即可。无论指针指向的数据类型是 `int`、`char`、`double` 等，并不会影响指针本身所占用的内存大小，因此不同数据类型的指针一般都占用相同的内存空间。



### 2.指针域为什么要这样定义？ 
next 就是指向下一个节点的指针域。可以看到，指针域是一个指向 struct ListNode 类型的指针，它存储了下一个节点的地址信息，也就是说，通过 next 指针，我们可以在链表中顺序遍历每一个节点。

对于双向链表和循环链表来说，节点的指针域的内容可能会有所不同，但原理基本相同：指针域存储了与当前节点有关的指针信息，方便对链表进行遍历、插入、删除等操作。  

指针在链表操作中扮演了非常重要的角色，它用于将链表中的不同节点进行连接。由于链表中每个节点都包含了下一个节点的地址信息，所以我们需要使用指针来存储这个地址。而指针本身也是一个数据类型，因此我们还需要声明它的类型。

在上述代码中，我们通过将 next 声明为 struct ListNode* 类型的指针来实现这个功能，使得 next 存储的地址可以被正确地解析为下一个节点。同时，在单链表中，由于只需要访问到下一个节点，因此只需要一个指针就足够了。

###  3.数据域里面的数据可以如何定义？  
链表的数据域



是指用来存储数据的部分，其具体类型和含义可以根据实际需求而定。在链表节点中，一般使用一个结构体或类来表示节点中存储的数据信息。

举个例子，比如单链表中的节点结构体定义如下：
	
```c
struct ListNode {
    int val;            // 数据域，整数类型
    struct ListNode* next;   // 指针域，指向下一个节点的指针
};
```
其中 val 就表示链表节点中存储的数据，这里是一个整数类型。当然，根据实际情况，数据域可以是任何合适的数据类型，比如字符串、浮点数、自定义结构体等。

如果需要存储更加复杂的数据类型，比如结构体或者类，可以直接将其作为节点的数据域，例如：
	
```c
struct StudentInfo {
    char name[50];     // 学生姓名
    int age;           // 学生年龄
    float score;       // 学生成绩
};

struct ListNode {
    struct StudentInfo info;  // 数据域，学生信息结构体
    struct ListNode* next;    // 指针域，指向下一个节点的指针
};
```
在实际开发中，数据域的类型以及具体包含的信息应该根据实际需求进行设计，满足程序的功能需求并提高代码的可读性和扩展性。  




